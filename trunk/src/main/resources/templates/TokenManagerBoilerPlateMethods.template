#if TOKEN_MANAGER_USES_PARSER && !STATIC
    /** Constructor with parser. */
    public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream){
    parser = parserArg;
#else
    /** Constructor. */
    public ${tokMgrClassName}(${charStreamName} stream){
#fi

#if STATIC && !USER_CHAR_STREAM
      if (input_stream != null)
        throw new ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}.STATIC_LEXER_ERROR);
#elif !USER_CHAR_STREAM
    #if JAVA_UNICODE_ESCAPE
      if (JavaCharStream.staticFlag)
    #else
      if (SimpleCharStream.staticFlag)
    #fi
            throw new ${LEGACY_EXCEPTION_HANDLING?Error:RuntimeException}("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
#fi

    input_stream = stream;
  }

#if TOKEN_MANAGER_USES_PARSER && !STATIC
  /** Constructor with parser. */
  public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream, int lexState){
    ReInit(parserArg, stream);
  }
#else
  /** Constructor. */
  public ${tokMgrClassName} (${charStreamName} stream, int lexState){
    ReInit(stream);
    SwitchTo(lexState);
  }
#fi

  /** Reinitialise parser. */
  
#if TOKEN_MANAGER_USES_PARSER && !STATIC
  public void ReInit(${cu_name} parserArg, ${charStreamName} stream)
#else
  ${STATIC?static :}public void ReInit(${charStreamName} stream)
#fi
  {
#if TOKEN_MANAGER_USES_PARSER && !STATIC
	this.parser = parserArg;
#else

#fi

    jjmatchedPos =
#if !TABLE_DRIVEN
    jjnewStateCnt =
#fi
    0;
    curLexState = defaultLexState;
    input_stream = stream;
#if !TABLE_DRIVEN
    ReInitRounds();
#fi
  }

#if !TABLE_DRIVEN
  ${STATIC?static :}private void ReInitRounds()
  {
    int i;
    jjround = 0x80000001;
    for (i = ${stateSetSize}; i-- > 0;)
      jjrounds[i] = 0x80000000;
  }
#fi

  /** Reinitialise parser. */
#if TOKEN_MANAGER_USES_PARSER && !STATIC
  public void ReInit( ${cu_name} parserArg, ${charStreamName} stream, int lexState)
#else
  ${STATIC?static :}public void ReInit(${charStreamName} stream, int lexState)
#fi
  
  {
#if TOKEN_MANAGER_USES_PARSER && !STATIC
    ReInit(parserArg, stream);
#else
    ReInit(stream);
#fi
    SwitchTo(lexState);
  }

  /** Switch to specified lex state. */
  public ${STATIC?static :}void SwitchTo(int lexState)
  {
    if (lexState >= ${lexStateNameLength} || lexState < 0)
      throw new ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}.INVALID_LEXICAL_STATE);
    else
      curLexState = lexState;
  }

#if TABLE_DRIVEN

private static final java.util.Map<Long, int[]> finalStates =
    new java.util.HashMap<Long, int[]>();
private static final java.util.Map<Long, int[]> validKinds =
    new java.util.HashMap<Long, int[]>();
static {
  int i = 0;
  while (i < charPosTransitions.length) {
    int pos = charPosTransitions[i++];
    int numChars = charPosTransitions[i++];
    for (int j = 0; j < numChars; j++) {
      char c = (char)charPosTransitions[i++];
      long key = (long)c << 32 | pos;

      int numFinalStates = charPosTransitions[i++];
      if (numFinalStates > 0) {
        int[] arr = new int[numFinalStates * 2];
        for (int k = 0; k < arr.length; k += 2) {
          arr[k] = charPosTransitions[i++];
          arr[k + 1] = charPosTransitions[i++];
        }
        finalStates.put(key, arr);
      }

      int numValidKinds = charPosTransitions[i++];
      if (numValidKinds > 0) {
        int[] arr = new int[numValidKinds];
        for (int k = 0; k < numValidKinds; k++) {
          arr[k] = charPosTransitions[i++];
        }
        validKinds.put(key, arr);
      }
    }
  }
}

// Bit vector to track possible kinds. maxLongs = MAX(kind) / 64 + 1;
private static final long[] jjcurActive = new long[${maxLongs}];
private static final long[] jjnewActive = new long[${maxLongs}];
private ${STATIC?static :}final int jjRunDfa() {
  int curPos = 0;
  int nfaState = Integer.MAX_VALUE;
  for (int i = 0; i < ${maxLongs}; i++) jjcurActive[i] = 0xffffffffffffffffL;
  do {
    final long key = (long)curChar << 32 | curPos;
    // Algorithm: Keep trying to match a DFA as long as there is one
    // possible and in the end, start the NFA if the string literal token
    // match can also be a prefix of non-string literal token.

    final int[] kindAndNext = finalStates.get(key);
    if (kindAndNext != null) {
      // The current input character at the current position marks the end
      // of a literal token match e.g., pos == 2 and curChar == 'r' can
      // potentially mark the token "for" in Java grammar.
      for (int i = 0; i < kindAndNext.length; i += 2) {
        int kind = kindAndNext[i];
        // See if this kind is feasible based on the prefix. So for examaple,
        // in Java grammar, pos == 3 and curChar == 'e' can indicate the match
        // of one the 4 tokens - "byte", "case", "else", "true".
        // The jjcurActive bit mask tracks the feasible ones as we go through
        // input. So if the kind is one of the currently active kinds to 
        // be matched, we match it.
        if ((jjcurActive[kind >> 6] & (1L << (kind % 64))) != 0L) {
          // Store the kind matched so far.
          jjmatchedPos = curPos;
          jjmatchedKind = kind;
          nfaState = kindAndNext[i + 1];
          if (nfaState > 0) {
            try { curChar = input_stream.readChar(); }
            catch(java.io.IOException e) { return curPos + 1; }
            return jjMoveNfa(nfaState, curPos + 1);
          }
        }
      }
    }

    // curChar at curPos is a prefix of another string literal token.
    // So for example in Java grammar, curChar == 't' and and
    // curPos == '2', then this could end up begin the "interface" token.
    boolean continueDfa = false;
    int[] validKind = validKinds.get(key);
    if (validKind != null) {
      for (final int kind : validKind) {
        if ((jjcurActive[kind >> 6] & (1L << (kind % 64))) != 0L) {
          continueDfa = true;
          break;
        }
      }

      if (continueDfa) {
        for (int i = 0; i < ${maxLongs}; i++) jjnewActive[i] = 0L;
        for (final int kind : validKind) {
          jjnewActive[kind >> 6] |= 1L << (kind % 64);
        }
        for (int i = 0; i < ${maxLongs}; i++) jjcurActive[i] &= jjnewActive[i];
      }
    }

    if (!continueDfa) {
      if (nfaState != Integer.MAX_VALUE) {
        input_stream.backup(curPos - jjmatchedPos);
        try { curChar = input_stream.readChar(); }
        catch(java.io.IOException e) { return jjmatchedPos + 1; }
        return jjMoveNfa(-nfaState, jjmatchedPos + 1);
      }
      input_stream.backup(curPos);
      return jjMoveNfa(0,0);
    }

    int i = 0;
    for (; i < ${maxLongs}; i++) {
      if (jjcurActive[i] != 0L) break;
    }
    if (i == ${maxLongs}) {
      // No more NFA or DFS possible so just return. For example, in Java
      // grammar, when curPos == 1 and curChar == "|" it will return a
      // "||" token as it is not a prefix of any other token.
      return curPos + 1;
    }

    // Move to the next character.
    try {
      // We cannot update curChar unless we can actually advance the stream.
      curChar = input_stream.readChar();
    } catch(java.io.IOException e) {
      if (nfaState != Integer.MAX_VALUE) {
        input_stream.backup(curPos - jjmatchedPos);
        try { curChar = input_stream.readChar(); }
        catch(java.io.IOException e2) { return jjmatchedPos + 1; }
        return jjMoveNfa(-nfaState, jjmatchedPos + 1);
      }
      input_stream.backup(curPos);
      return jjMoveNfa(0,0);
    }
    curPos++;
  } while(true);
}

// NFA related data, initialization and code.
private static final long[][] jjChars =
    new long[${generatedStates}][Character.MAX_VALUE/64 + 1];
static {
  for (int i = 0; i < ${generatedStates}; i++) {
    int ind = 0;
    for (int j = 0; j < jjCharData[i].length; j += 2) {
      for (int k = 0; k < (int)jjCharData[i][j]; k++) {
        jjChars[i][ind++] = jjCharData[i][j + 1];
      }
    }
  }
}

private static  int[] stateSet = new int[${generatedStates}];
private static  int[] newStateSet = new int[${generatedStates}];
private static  final long[] moved = new long[${generatedStates}];
private static long moveIndex = 0L;

private ${STATIC?static :}final int jjMoveNfa(int startState, int curPos) {

  if (startState < 0) {
    return curPos + 1;
  }

  if (++moveIndex == Long.MAX_VALUE) {
    for (int i = 0; i < ${generatedStates}; i++) moved[i] = 0L;
    moveIndex = 1L;
  }
  int kind = 0x7fffffff;
  stateSet[0] = startState;
  moved[startState] = moveIndex;
  int cnt = 1;
  for (int s : jjcompositeState[startState]) { 
    if (moved[s] != moveIndex) {
      stateSet[cnt++] = s;
      moved[s] = moveIndex;
    }
  }
  do {
    int newCnt = 0;
    if (++moveIndex == Long.MAX_VALUE) {
      for (int i = 0; i < ${generatedStates}; i++) moved[i] = 0L;
      moveIndex = 1L;
    }
    final int vectorIndex = curChar / 64;
    final long bitpattern = (1L << (curChar % 64));
    do {
      final int state = stateSet[--cnt];
      if ((jjChars[state][vectorIndex] & bitpattern) != 0L) {
        for (int newState : jjnextStateSet[state]) {
          if (moved[newState] != moveIndex) {
            newStateSet[newCnt++] = newState;
            moved[newState] = moveIndex;
          }
        }
        final int newKind = jjmatchKinds[state];
        if (kind > newKind) kind = newKind;
      }
    } while (cnt > 0);

    if (kind != 0x7fffffff) {
       if (jjmatchedPos != curPos || jjmatchedKind > kind) {
         jjmatchedKind = kind;
       }
       jjmatchedPos = curPos;
       kind = 0x7fffffff;
    }

    int[] tmp = stateSet;
    stateSet = newStateSet;
    newStateSet = tmp;
    cnt = newCnt;
    ++curPos;
    if (newCnt == 0) {
      return curPos;
    }
    try {
      curChar = input_stream.readChar();
    } catch(java.io.IOException e) {
      return curPos;
    }
  } while (cnt > 0);

  assert(false) :
      "Interal error. Please submit a bug at: http://javacc.java.net.";
  return curPos;
}

${STATIC?static :} int defaultLexState = ${defaultLexState};
${STATIC?static :} int curLexState = ${defaultLexState};
${STATIC?static :} int jjmatchedPos;
${STATIC?static :} int jjmatchedKind;

/** Get the next Token. */
public ${STATIC?static :} Token getNextToken() {
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(Exception e)
   {
      jjmatchedKind = 0;
      jjmatchedPos = -1;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }

   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjRunDfa();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         matchedToken.specialToken = specialToken;
         return matchedToken;
      }
      else
      {
         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
            if (specialToken == null)
               specialToken = matchedToken;
            else
            {
               matchedToken.specialToken = specialToken;
               specialToken = (specialToken.next = matchedToken);
            }
         }
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? "" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? "" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}

#fi

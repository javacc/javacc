#if TOKEN_MANAGER_USES_PARSER && !STATIC
    /** Constructor with parser. */
    public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream){
    parser = parserArg;
#else
    /** Constructor. */
    public ${tokMgrClassName}(${charStreamName} stream){
#fi

#if STATIC && !USER_CHAR_STREAM
      if (input_stream != null)
        throw new ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}.STATIC_LEXER_ERROR);
#elif !USER_CHAR_STREAM
    #if JAVA_UNICODE_ESCAPE
      if (JavaCharStream.staticFlag)
    #else
      if (SimpleCharStream.staticFlag)
    #fi
            throw new ${LEGACY_EXCEPTION_HANDLING?Error:RuntimeException}("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
#fi

    input_stream = stream;
  }

#if TOKEN_MANAGER_USES_PARSER && !STATIC
  /** Constructor with parser. */
  public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream, int lexState){
    ReInit(parserArg, stream);
  }
#else
  /** Constructor. */
  public ${tokMgrClassName} (${charStreamName} stream, int lexState){
    ReInit(stream);
    SwitchTo(lexState);
  }
#fi

  /** Reinitialise parser. */
  
#if TOKEN_MANAGER_USES_PARSER && !STATIC
  public void ReInit(${cu_name} parserArg, ${charStreamName} stream)
#else
  ${STATIC?static :}public void ReInit(${charStreamName} stream)
#fi
  {
#if TOKEN_MANAGER_USES_PARSER && !STATIC
	this.parser = parserArg;
#else

#fi

    jjmatchedPos =
#if !TABLE_DRIVEN
    jjnewStateCnt =
#fi
    0;
    curLexState = defaultLexState;
    input_stream = stream;
#if !TABLE_DRIVEN
    ReInitRounds();
#fi
  }

#if !TABLE_DRIVEN
  ${STATIC?static :}private void ReInitRounds()
  {
    int i;
    jjround = 0x80000001;
    for (i = ${stateSetSize}; i-- > 0;)
      jjrounds[i] = 0x80000000;
  }
#fi

  /** Reinitialise parser. */
#if TOKEN_MANAGER_USES_PARSER && !STATIC
  public void ReInit( ${cu_name} parserArg, ${charStreamName} stream, int lexState)
#else
  ${STATIC?static :}public void ReInit(${charStreamName} stream, int lexState)
#fi
  
  {
#if TOKEN_MANAGER_USES_PARSER && !STATIC
    ReInit(parserArg, stream);
#else
    ReInit(stream);
#fi
    SwitchTo(lexState);
  }

  /** Switch to specified lex state. */
  public ${STATIC?static :}void SwitchTo(int lexState)
  {
    if (lexState >= ${lexStateNameLength} || lexState < 0)
      throw new ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", ${LEGACY_EXCEPTION_HANDLING?TokenMgrError:TokenMgrException}.INVALID_LEXICAL_STATE);
    else
      curLexState = lexState;
  }

#if TABLE_DRIVEN

private static final java.util.Map<Long, int[]> finalStates =
    new java.util.HashMap<Long, int[]>();
private static final java.util.Map<Long, int[]> validKinds =
    new java.util.HashMap<Long, int[]>();
static {
  int i = 0;
  while (i < charPosTransitions.length) {
    int pos = charPosTransitions[i++];
    int numChars = charPosTransitions[i++];
    for (int j = 0; j < numChars; j++) {
      char c = (char)charPosTransitions[i++];
      long key = (long)c << 32 | pos;

      int numFinalStates = charPosTransitions[i++];
      if (numFinalStates > 0) {
        int[] arr = new int[numFinalStates * 2];
        for (int k = 0; k < arr.length; k += 2) {
          arr[k] = charPosTransitions[i++];
          arr[k + 1] = charPosTransitions[i++];
        }
        finalStates.put(key, arr);
      }

      int numValidKinds = charPosTransitions[i++];
      if (numValidKinds > 0) {
        int[] arr = new int[numValidKinds];
        for (int k = 0; k < numValidKinds; k++) {
          arr[k] = charPosTransitions[i++];
        }
        validKinds.put(key, arr);
      }
    }
  }
}

// Bit vector to track possible kinds. maxLongs = MAX(kind) / 64 + 1;
private static final long[] jjcurActive = new long[${maxLongs}];
private static final long[] jjnewActive = new long[${maxLongs}];
private ${STATIC?static :}final int jjRunStringLiteralMatch() {
  int curPos = 0;
  int nfaState = -1;
  for (int i = 0; i < ${maxLongs}; i++) jjcurActive[i] = 0xffffffffffffffffL;
  do {
    final long key = (long)curChar << 32 | curPos;
    // Algorithm: Keep trying to match a DFA as long as there is one
    // possible and in the end, start the NFA if the string literal token
    // match can also be a prefix of non-string literal token.

    final int[] kindAndNext = finalStates.get(key);
    if (kindAndNext != null) {
      // The current input character at the current position marks the end
      // of a literal token match e.g., pos == 2 and curChar == 'r' can
      // potentially mark the token "for" in Java grammar.
      for (int i = 0; i < kindAndNext.length; i += 2) {
        int kind = kindAndNext[i];
        // See if this kind is feasible based on the prefix. So for examaple,
        // in Java grammar, pos == 3 and curChar == 'e' can indicate the match
        // of one the 4 tokens - "byte", "case", "else", "true".
        // The jjcurActive bit mask tracks the feasible ones as we go through
        // input. So if the kind is one of the currently active kinds to 
        // be matched, we match it.
        if ((jjcurActive[kind >> 6] & (1L << (kind & 077))) != 0L) {
          // Store the kind matched so far.
          jjmatchedPos = curPos;
          jjmatchedKind = kind;
          nfaState = kindAndNext[i + 1];
        }
      }
    }

    // curChar at curPos is a prefix of another string literal token.
    // So for example in Java grammar, curChar == 't' and and
    // curPos == '2', then this could end up begin the "interface" token.
    boolean continueDfa = false;
    int[] validKind = validKinds.get(key);
    if (validKind != null) {
      for (final int kind : validKind) {
        if ((jjcurActive[kind >> 6] & (1L << (kind & 077))) != 0L) {
          continueDfa = true;
          break;
        }
      }

      if (continueDfa) {
        for (int i = 0; i < ${maxLongs}; i++) jjnewActive[i] = 0L;
        for (final int kind : validKind) {
          jjnewActive[kind >> 6] |= 1L << (kind & 077);
        }
        for (int i = 0; i < ${maxLongs}; i++) jjcurActive[i] &= jjnewActive[i];
      }
    }

    if (!continueDfa) {
      return backTrackToNfa(nfaState, curPos);
    }

    int i = 0;
    for (; i < ${maxLongs}; i++) {
      if (jjcurActive[i] != 0L) break;
    }
    if (i == ${maxLongs}) {
      // No more NFA or DFS possible so just return. For example, in Java
      // grammar, when curPos == 1 and curChar == "|" it will return a
      // "||" token as it is not a prefix of any other token.
      return curPos;
    }

    // Move to the next character.
    try {
      // We cannot update curChar unless we can actually advance the stream.
      curChar = input_stream.readChar();
    } catch(java.io.IOException e) {
      return backTrackToNfa(nfaState, curPos);
    }
    curPos++;
  } while(true);
}

private ${STATIC?static :} final int backTrackToNfa(int nfaState, int curPos) {
  if (jjmatchedKind != Integer.MAX_VALUE) {
    input_stream.backup(curPos - jjmatchedPos);
    if (nfaState > 0) {
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e3) { return jjmatchedPos; }
      return jjMoveNfa(nfaState, jjmatchedPos + 1);
    }
    return jjmatchedPos;
  }
  input_stream.backup(curPos + 1);
  try { curChar = input_stream.readChar(); }
  catch(java.io.IOException e) { assert(false); }
  return jjMoveNfa(0, 0);
}

// NFA related data, initialization and code.
private static final long[][] jjChars =
    new long[${generatedStates}][Character.MAX_VALUE/64 + 1];
static {
  for (int i = 0; i < ${generatedStates}; i++) {
    int ind = 0;
    for (int j = 0; j < jjCharData[i].length; j += 2) {
      for (int k = 0; k < (int)jjCharData[i][j]; k++) {
        jjChars[i][ind++] = jjCharData[i][j + 1];
      }
    }
  }
}

private static  int[] stateSet = new int[${generatedStates}];
private static  int[] newStateSet = new int[${generatedStates}];
private static  final long[] moved = new long[${generatedStates}];
private static long moveIndex = 0L;

private ${STATIC?static :}final int jjMoveNfa(int startState, int curPos) {

  if (startState < 0) {
    return curPos;
  }

  if (++moveIndex == Long.MAX_VALUE) {
    for (int i = 0; i < ${generatedStates}; i++) moved[i] = 0L;
    moveIndex = 1L;
  }
  int kind = Integer.MAX_VALUE;
  stateSet[0] = startState;
  moved[startState] = moveIndex;
  int cnt = 1;
  for (int s : jjcompositeState[startState]) { 
    if (moved[s] != moveIndex) {
      stateSet[cnt++] = s;
      moved[s] = moveIndex;
    }
  }
  do {
    int newCnt = 0;
    if (++moveIndex == Long.MAX_VALUE) {
      for (int i = 0; i < ${generatedStates}; i++) moved[i] = 0L;
      moveIndex = 1L;
    }
    final int vectorIndex = curChar / 64;
    final long bitpattern = (1L << (curChar & 077));
    do {
      final int state = stateSet[--cnt];
      if ((jjChars[state][vectorIndex] & bitpattern) != 0L) {
        for (int newState : jjnextStateSet[state]) {
          if (moved[newState] != moveIndex) {
            newStateSet[newCnt++] = newState;
            moved[newState] = moveIndex;
          }
        }
        final int newKind = jjmatchKinds[state];
        if (kind > newKind) kind = newKind;
      }
    } while (cnt > 0);

    if (kind != Integer.MAX_VALUE) {
       jjmatchedKind = kind;
       jjmatchedPos = curPos;
       kind = Integer.MAX_VALUE;
    }

    int[] tmp = stateSet;
    stateSet = newStateSet;
    newStateSet = tmp;
    cnt = newCnt;
    if (newCnt == 0) {
      return curPos;
    }
    try {
      curChar = input_stream.readChar();
    } catch(java.io.IOException e) {
      return curPos;
    }
    ++curPos;
  } while (cnt > 0);

  assert(false) :
      "Interal error. Please submit a bug at: http://javacc.java.net.";
  return curPos;
}

private ${STATIC?static :} int defaultLexState = ${defaultLexState};
private ${STATIC?static :} int curLexState = ${defaultLexState};
private ${STATIC?static :} int jjmatchedPos;
private ${STATIC?static :} int jjmatchedKind;
private ${STATIC?static :} int jjimageLen;
private ${STATIC?static :} int lengthOfMatch;;

public static final boolean isToken(int kind) {
  return (jjtoToken[kind >> 6] & (1L << (kind & 077))) != 0L;
}

public static final boolean isSkip(int kind) {
  return (jjtoSkip[kind >> 6] & (1L << (kind & 077))) != 0L;
}

public static final boolean isSpecial(int kind) {
  return (jjtoSpecial[kind >> 6] & (1L << (kind & 077))) != 0L;
}

public static final boolean isMore(int kind) {
  return (jjtoMore[kind >> 6] & (1L << (kind & 077))) != 0L;
}

/** Get the next Token. */
public ${STATIC?static :} Token getNextToken() {
  Token specialToken = null;
  Token matchedToken;
  int lastReadPosition = 0;

  EOFLoop:
  for (;;) {
    // First see if we have any input at all.
    try {
      curChar = input_stream.BeginToken();
    } catch(Exception e) {
      // No input. So return EOF token.
      jjmatchedKind = EOF;
      jjmatchedPos = -1;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
    }

    // Set matched kind to a MAX VALUE to implement largest, first occuring rule
    // i.e., smallest kind value matched should be used.
    jjmatchedKind = Integer.MAX_VALUE;
    jjmatchedPos = 0;
    lastReadPosition = jjRunStringLiteralMatch();
    if (jjmatchedKind != Integer.MAX_VALUE) {
      // We have a match!

      // Put back any characters looked ahead.
      input_stream.backup(lastReadPosition - jjmatchedPos);
      if (isToken(jjmatchedKind)) {
        // Matched kind is a real TOKEN.
        matchedToken = jjFillToken();
        matchedToken.specialToken = specialToken;
        TokenLexicalActions(matchedToken);
        if (jjnewLexState[jjmatchedKind] != -1) {
          curLexState = jjnewLexState[jjmatchedKind];
        }
        return matchedToken;
      } else if (isSkip(jjmatchedKind)) {
        // Matched kind is a SKIP or SPECIAL_TOKEN.
        if (isSpecial(jjmatchedKind)) {
          matchedToken = jjFillToken();
          if (specialToken == null) {
            specialToken = matchedToken;
          } else {
            matchedToken.specialToken = specialToken;
            specialToken = (specialToken.next = matchedToken);
          }
          SkipLexicalActions(matchedToken);
        } else {
          SkipLexicalActions(null);
        }
        if (jjnewLexState[jjmatchedKind] != -1) {
          curLexState = jjnewLexState[jjmatchedKind];
        }
        continue EOFLoop;
      }
      // Here it's a MORE.
      MoreLexicalActions();
      if (jjnewLexState[jjmatchedKind] != -1) {
        curLexState = jjnewLexState[jjmatchedKind];
      }
      lastReadPosition = 0;
      jjmatchedKind = 0x7fffffff;
      try {
        curChar = input_stream.readChar();
        continue;
      }
      catch (java.io.IOException e1) { }
    }
    reportError(lastReadPosition);
    return null;  // Should never come here.
  }
}

protected ${STATIC?static :} void reportError(int lastReadPosition) {
  int error_line = input_stream.getEndLine();
  int error_column = input_stream.getEndColumn();
  String error_after = null;
  boolean EOFSeen = false;
  try {
    input_stream.readChar();
    input_stream.backup(1);
  } catch (java.io.IOException e1) {
    EOFSeen = true;
    error_after = lastReadPosition <= 1 ? "" : input_stream.GetImage();
    if (curChar == '\n' || curChar == '\r') {
       error_line++;
       error_column = 0;
    }
    else
       error_column++;
  }
  if (!EOFSeen) {
    input_stream.backup(1);
    error_after = lastReadPosition <= 1 ? "" : input_stream.GetImage();
  }
  throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column,
                          error_after, curChar, TokenMgrError.LEXICAL_ERROR);
}

#fi

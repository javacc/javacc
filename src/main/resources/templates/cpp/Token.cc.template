\#include "Token.h"

#if NAMESPACE
namespace ${NAMESPACE_OPEN}
#fi

/**
 * Describes the input token stream.
 */

  /**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-NULL value can
   * override this method as appropriate.
   */
  void * Token::getValue() {
    return nullptr;
  }

  /**
   * No-argument constructor
   */
  Token::Token() : _kind(0), _next(nullptr),
    _beginLine(0), _beginColumn(0), _endLine(0), _endColumn(0),
    _specialToken(nullptr)
  {
  }
  /**
   * Constructs a new token for the specified Image.
   */
  Token::Token(int kind) : _kind(kind), _next(nullptr),
    _beginLine(0), _beginColumn(0), _endLine(0), _endColumn(0),
    _specialToken(nullptr)
  {
  }

  /**
   * Constructs a new token for the specified Image and Kind.
   */
  Token::Token(int kind, const JJString& image) : _kind(kind), _image(image),
    _next(nullptr),
    _beginLine(0), _beginColumn(0), _endLine(0), _endColumn(0),
    _specialToken(nullptr)
  {
  }

  Token::~Token() {
    if (_specialToken) delete _specialToken, _specialToken = nullptr;
    _kind = _beginLine = _beginColumn = _endLine = _endColumn = 0;
    _next = nullptr;
    
  }

  /**
   * Returns the image.
   */
  const JJString& Token::image() const
  {
    return _image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */
  Token *Token::newToken(int ofKind, const JJString& image)
  {
    switch(ofKind)
    {
      default : return new Token(ofKind, image);
    }
  }

  Token *Token::newToken(int ofKind)
  {
    return newToken(ofKind, JJString());
  }

  const int& Token::kind() const 
  { 
  	return _kind; 
  }
  const Token* Token::next() const 
  {
    return _next;
  }
  Token*& Token::next()
  {
    return _next;
  }
  const Token* Token::specialToken() const 
  {
    return _specialToken;
  }
  Token*& Token::specialToken()
  {
    return _specialToken;
  }
  const int& Token::beginLine() const
  {
    return _beginLine;
  }
  const int& Token::beginColumn() const
  {
    return _beginColumn;
  }
  const int& Token::endLine() const
  {
    return _endLine;
  }
  const int& Token::endColumn() const
  {
    return _endColumn;
  }
  const JJString& Token::toString() const
  {
    return _image;
  }
  

#if NAMESPACE
${NAMESPACE_CLOSE}
#fi
